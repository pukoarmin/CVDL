# -*- coding: utf-8 -*-
"""Computer Vision and Deep Learning - Laboratory 1 [Students].ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sNWsaDoP1TQcaSKtXo18xtPpwkLAO26t

# Laboratory 1

Hello and welcome to your first laboratory! :)

This is an introductory session to Python and a few libraries that we'll frequently use in this course (numpy, matplotlib, opencv, keras). 

After completing this session, you will:
* gain some basic image manipulation skills
* be able to vectorize code (avoid using for loops)
* get familiar with the concept of broadcasting in numpy

For some of the exercises you'll have the expected output displayed just below the cell, so that you can check if your output is correct.
"""

# Commented out IPython magic to ensure Python compatibility.
# library imports
import cv2
import tensorflow.keras as keras
import numpy as np
import matplotlib.pyplot as plt

# %matplotlib inline
#The line above is necesary to show Matplotlib's plots inside a Jupyter Notebook

!wget "http://drive.google.com/uc?export=download&id=1fRvlErNtIV-HX9Vat0I6FINBXEafeDC7" -O dance_moves.png
!wget "https://docs.google.com/uc?export=download&id=1zjltpYscUqnDSP6eUlU-gecadGXvQtTz" -O cute_cat.jpg
!wget "http://drive.google.com/uc?export=download&id=1y46KaIsyhgh030Zi9eoAYfO_ezkE4CY3" -O axes.jpg
!wget "http://drive.google.com/uc?export=download&id=11Jzu1t1RVXMWxp0OK3KJaUgKv9exqv2O" -O sum0.jpg
!wget "http://drive.google.com/uc?export=download&id=1LUYh0HtP6Vd2eq7rPXOhXjBKXlvU--L5" -O sum1.jpg
!wget "http://drive.google.com/uc?export=download&id=1q_BsBdLZXxA2fkrY1WXWn8B5RGOFBLUd" -O concat0.jpg
!wget "http://drive.google.com/uc?export=download&id=1491c1NZQMOnHlvVp6eiiIl2l1wYO6o56" -O concat1.jpg

"""# *numpy*

We'll frequently use the *numpy* library for this lecture; *numpy* is perhaps the most popular library used for scientific computing in Python. *numpy* works with multidimensional arrays, and provides several operations to efficiently manipulate these arrays.

An array contains elements of the same type, arranged in a grid of values. An array can be accessed by a tuple of non-negative integers, by booleans, by another array, or by integers, as we'll see later in this laboratory.

An array is described by its:
- rank - the number of dimensions of the array
- shape - a tuple that specifies the size of the array along each dimension
- type - the library provides several numeric datatypes (uint8, float32, int32 etc.)

There are several ways you can create an array in numpy:
"""

# create an array with rank 1
a = np.array([1, 2, 3])   
print('a is a numpy array ', type(a))            
print('the shape of a is ', a.shape, ' and its rank is ', len(a.shape))
print('the type of the elements stored in a is ', a.dtype)
print('---')
b = np.array([[1.0, 2, 3],[4, 5, 6]])   
print('the shape of b is ', b.shape, ' and its rank is ', len(b.shape))
print('the type of the elements stored in b is ', b.dtype) 
print('---')
# numpy automatically determines the type of the elements that will be stored in the array
# but you can also specify the type in the constructor
c = np.array([[[0]]], dtype=np.uint8)
print('the shape of c is ', c.shape, ' and its rank is ', len(c.shape))
print('the type of the elements stored in c is ', c.dtype)

# there are also other array constructors that you might find useful
a = np.zeros(shape=(1, 2)) # creates an array filled with 0s of shape (1, 2) - 1 row, two columns
print('zeros array {} of shape {}'.format(a, a.shape))

b = np.ones((224, 224, 3), dtype=np.uint8) # creates an array filled with ones of shape (224, 224, 3) and type uint8

c = np.full((4, 4, 3), 255) # creates an array filled with 255 of shape (4, 4, 3) 

d = np.eye(3) # creates an identity matrix of size (3x3)
print('identity matrix of size 3x3 ', d)

r = np.random.random(10) # creates an array of 10 elements, filled with random values
print('array of 10 random elements ', r)

zl = np.zeros_like(r) # create a new array with the same shape as r, but filled with 0 values

"""## Indexing"""

a = np.array([1, 2, 3])
print('a is ', a)
a[2] = 4
print('Set the 2nd element to 4')
print('Modified a is:')
print(a)

print('---')
b = np.eye(3)
b[1, 1] = 2
print('Modified b is')
print(b)

# you can use normal integer indexing
print('The first row of b is: ', b[0])
print('The second element from the second row of b is ', b[1, 1])



"""Similar to python lists, *numpy* allows you to <i>slice</i> the array; this is just a  flexible way to access subarrays."""

# slicing
a = np.arange(1, 10, 1) # returns an array with evenly spaced values in the interval [1, 10), with a step of 1
[1, 2, 3, 4, ..., 9]
print('a is \n', a)
print('a[3:6] is \n', a[3:6])   # get a slice from index 3 to 6 (exclusive)
print('a[3:] is \n', a[3:])    # get a slice from index 3 to the end
print('a[:3] is \n', a[:3])    # get a slice from the start to index 3 (exclusive)
print('a[4:-1] is \n', a[4:-1])  # get a slice from index 4 start to the last element of the array (exclusive)

print('---')

a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
print('a: ', a)

## ATTENTION! a slice is just a view on an array, so it points to the same data
# modifying it, it will modify the original array
r = a[:1,:]
print('row1:',  r)
print('a[0][0]: ', a[0, 0])
print('r[0][0]: ', r[0, 0])
print('r[0, 0] = 100')
r[0, 0] = 100
print('row1:',  r)
print('a[0][0]: ', a[0, 0])
print('r[0][0]: ', r[0, 0])

"""*numpy* also support integer array indexing.

Attention, there is a slight (and important) difference when using integer array indexing: when using slicing, the result will also be a subarray of the existing array (a view on the existing array), while integer array indexing allows you to create new arrays based on the the data in the original array.
"""

a = np.array(np.arange(0, 6, 1))
indices = [0, 2, 4] 
b = a[indices] # this will get the elements from the indices 0, 2, 4 from the array a
print('original array: \n', a)
print('The elements in a from the indices', indices, 'are: \n', b)
print('---')

a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
indices = [[0, 1, 2], [2, 1, 0]] # this will get the elements from the indices (0, 2), (1, 1) and (2, 0) from the array a
b = a[tuple(indices)]  # b will be [3, 6, 9]
print('original array: \n', a)
print('The elements in the array at indices', indices, 'are: \n', b)

print('---')
# modifying this array, won't modify the original array
print(b)
b[0] = 100
print('b[0] = 100')
print('a = ', a)
print('b = ', b)

print('---')
print('More array indexing examples: ')
# with array indexing you can reuse the same index from the original array
b = a[[0, 0], [1, 1]]
print('b = ', b)
#  equivalent to 
b = [a[0, 1], a[0, 1]]
print('b = ', b)

print('---')
print('Using array indexing to modify an element from each row in a matrix: ')
# modifing an element from each row in a matrix
ind = np.array([1, 0, 1])
a[np.arange(3), ind] = -100
print(a)

"""Array indexing can be mixed with slicing. When using slicing the resulting array will have the same rank as the original array, while when using array indexing you will get an array with a lower rank than the original array."""

a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
last_row_indexing = a[-1, :]
last_row_slicing = a[2:3, :]
print('Last row obtained with array indexing:\n', 
      last_row_indexing, 'has shape:', last_row_indexing.shape)
print('Last row obtained with array slicing:\n', 
      last_row_slicing, 'has shape:', last_row_slicing.shape)

"""*numpy* also allows you to use boolean array indexing, in which an array of booleans is used as a mask to select arbitrary elements in the array."""

a = np.array([11, 12, 13, 14])
indices = (a > 12)
# a > 12 returns an array of boolean of the same size as a;
# an element in this array is True is the element stored in the same position in a is larger than 12

print('a>12:\n', indices)
print('The numbers larger than 12 in a are:\n', a[indices])

"""## array operations
*numpy* provides functions and operator overload for various arithmetical operations on the arrays, such addition, subtraction, multiplication, dot products etc.


*Attention!!* **np.multiply** performs elementwise multiplication. If you want to perform matrix multiplication, you should use the **np.dot** function *!!*
"""

a = np.array([[1, 2], 
             [3, 4]])
b = np.array([[11, 12],
             [13, 14]])

print('a is: ', a)
print('b is: ', b)
# elementwise operations
print('a+b is: \n', a + b)
print('a+b is: \n', np.add(a, b))

print('a-b is: \n', a - b)
print('a-b is: \n', np.subtract(a, b))

print('The maximum element in a is :', np.amax(a))
print('The position of this element in a is :', np.argmax(a)) # by default it returns the max in the flattened array

print('|a-b| is: \n', np.abs(a - b))

print('a*b (element wise) is: \n', a*b)
print('a*b (element wise) is: \n', np.multiply(a, b))

v = np.array([10, 20])
w = np.array([11, 11])
print('Dot product v x w is:\n', v.dot(w))
print('Dot product v x w is:\n', np.dot(v, w))

print('Dot product a x v (matrix x vector) is:\n', a.dot(v))

print('Dot product a x b (matrix x matrix) is:\n', a.dot(b))

"""## numpy axes

Another concept that is perhaps confusing for beginners in numpy is the concept of axes. As you'll see several mathematical functions (**np.sum**, **np.mean**, **np.min** etc.) require you to specify the axis along the operation should be applied.

Just as the cartesian coordinate system, numpy arrays have axes. For example, for a 2D array, the rows are the first axis (0 axis), and the columns are the second axis (axis 1).


"""

img_axes = cv2.imread('axes.jpg')
dpi = plt.rcParams['figure.dpi']

height, width, depth = img_axes.shape
figsize = width / float(dpi), height / float(dpi)
plt.figure(figsize=figsize)
plt.imshow(img_axes)

"""Is is important to understand, for each operation, what the axis element controls.

For the common matemathical operations, which for example aggregate your data, the axis parameter controls which axis will be collapsed.
So, for example, if you have an array a, and you perform the operation np.sum(a, axis = 0), the rows will be collapsed and this will sum down the columns. (It will not sum the rows).

"""

img_sum0 = cv2.imread('sum0.jpg')
dpi = plt.rcParams['figure.dpi']

height, width, depth = img_sum0.shape
figsize = width / float(dpi), height / float(dpi)
plt.figure(figsize=figsize)
plt.imshow(img_sum0)

"""Similarly, if you have an array a, and you perform the operation np.sum(a, axis = 1), the columns will be collapsed and this will sum down the rows. (It will not sum the columns).

"""

img_sum1 = cv2.imread('sum1.jpg')
dpi = plt.rcParams['figure.dpi']

height, width, depth = img_sum1.shape
figsize = width / float(dpi), height / float(dpi)
plt.figure(figsize=figsize)
plt.imshow(img_sum1)

"""Another example, for the concatentaion operation, the axis operator specifies the axis along which to stack the arrays. 

If we specify the axis = 0 for concatenation, the arrays will be stacked along the rows (they will be concatenated vertically).

"""

img_concat0 = cv2.imread('concat0.jpg')
dpi = plt.rcParams['figure.dpi']

height, width, depth = img_concat0.shape
figsize = width / float(dpi), height / float(dpi)
plt.figure(figsize=figsize)
plt.imshow(img_concat0)

"""If we specify the axis = 1 for concatenation, the arrays will be stacked along the columns (they will be concatenated horizontally).


"""

img_concat1 = cv2.imread('concat1.jpg')
dpi = plt.rcParams['figure.dpi']

height, width, depth = img_concat1.shape
figsize = width / float(dpi), height / float(dpi)
plt.figure(figsize=figsize)
plt.imshow(img_concat1)

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

print('The sum of each column is: \n ', np.sum(a, axis = 0))

print('The sum of each row is: \n ', np.sum(a, axis = 1))

b = np.array([[1, 1, 1, 1], [2, 2, 2, 2]])

print('Concatenate vertically: \n', np.concatenate([a, b], axis = 0))

print('Concatenate horizontally: \n', np.concatenate([a, b], axis = 1))

# example with 1D arrays
a = np.array([0, 0, 0])
b = np.array([1, 1, 1])

print(np.concatenate([a, b], axis=0)) # attention! 1D arrays have only one axis

a = a.reshape((1, 3))
b = b[np.newaxis, :]

print(np.concatenate([a, b], axis=0))

# Good practice: reshape your arrays to (1, dim): a = a.reshape((1, 3))

"""## Vectorization

"<i>Vectorization is the art of getting rid of for loops in your code.</i>" (Andrew Ng)

numpy provides a series of functions that allow the programmer to perform mathematical computations on the elements of the array without having to explicitly loop over the array elements; these functions are much more efficient as python delegates these tasks to compiled and optimized C code.
 
A formal definiton of vectorization is:
"In the context of high-level languages like Python, Matlab, and R, the term vectorization describes the use of optimized, pre-compiled code written in a low-level language (e.g. C) to perform mathematical operations over a sequence of data. This is done in place of an explicit iteration written in the native language code." (check this tutorial for details: https://www.pythonlikeyoumeanit.com/Module3_IntroducingNumpy/VectorizedOperations.html)

Using for loops to access array elements (when dealing with large data) is highly inefficient, as demonstrated in the examples below.
Therefore, especially for this course, when we'll deal with a lot of training data and large neural network architectures, you should always use vectorization when writing your code. Otherwise, it will take a very very very :) long time to get your model to perform a single iteration over your training data.
"""

import numpy as np
import time
a1 = np.random.rand(1000000)
a2 = np.random.rand(1000000)

t1 = time.time()
dp_vectorized = a1.dot(a2)
time_vectorized = time.time() - t1

t1 = time.time()
dp_loops = 0
for i in range(0, a1.shape[0]):
    dp_loops += a1[i]*a2[i]
time_loops = time.time() - t1

print(dp_vectorized)
print(dp_loops)

print('Time to compute dot product using loops: ', time_loops, 'milliseconds')
print('Time to compute dot product using vectorization: ', time_vectorized, 'milliseconds')
print('Speedup ', time_loops/time_vectorized)


arr_size = []
arr_time_vectorized = []
arr_time_loops = []



for sz in range(100, 1000000, 10000):
    t1 = time.time()
    a1 = np.random.rand(sz)
    a2 = np.random.rand(sz)
    dp_vectorized = a1.dot(a2)
    time_vectorized = time.time() - t1

    t1 = time.time()
    dp_loops = 0
    for i in range(0, a1.shape[0]):
        dp_loops += a1[i]*a2[i]
    time_loops = time.time() - t1
    arr_size.append(sz)

    arr_time_vectorized.append(time_vectorized)
    arr_time_loops.append(time_loops)


plt.plot(arr_size, arr_time_vectorized, label='vectorized')
plt.plot(arr_size, arr_time_loops, label='using loops')
plt.legend()
plt.xlabel('array size')
plt.ylabel('execution time (ms)')
plt.show()

"""## Broadcasting

Broadcasting is a *numpy* features that allows us to perfom operations on arrays with different shapes; frequently we may need to work with arrays with different size and apply some operations on these arrays. With broadcasting, if the arrays don't have the same size, the smaller size array is "broadcast" to match the shape of the larger array. This also helps with vectorizing array operations.

To be able to broadcast, the size of the arrays in the trailing axes must be the same, or one of these dimensions must be 1.
If the arrays don't have the same rank, we add 1 dimensions to the left (prepend the shape property with ones), until the arrays have the same rank.

Always, the result of broadcasting is the maximum size along each dimension from the input arrays.

You can check this tutorial for further information: http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc 
"""

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # shape: (3, 3)
b = np.array([0, 1, 2]) # (3,)
             
x1 = np.array([[1, 2, 3]]) # shape: (1, 3)
x2 = np.array([1, 2, 3]).reshape((3, 1)) # shape: (3, 1)

print(x1+x2)
#np.array([[1], [2], [3]) -> (3,) -> (3, 1)
# [1, 2, 1]
# [2, 4, 2]
# [1, 2, 1]
# add the two vectors using broadcasting
s = a + b
print(s)

# the code snippet above is equvalent to the code below (but without making unnecessary copies)
print(b.shape)
b_expanded = np.tile(b, (3, 1)) # this stacks 3 copies of b -> (3, 3)
print(b_expanded.shape)
print(b_expanded)
s = a + b_expanded

# add a vector to each complun of a matrix
a = np.array([[1, 2, 3], [4, 5, 6]])
b = np.array([0, 2])
# transpose the matrix a (a.T) such that is has shape (3, 2), the array b has shape (2,)
# they can be broadcasted together and then we can transpose the result
print((a.T+b).T)

a = np.array([0, 1, 2, 3])
b = np.array([4, 5, 6])
print(a.shape)
print(b.shape)

try:
    print(a+b)
except ValueError:
    print('Unable to broadcast arrays with shapes ', a.shape, b.shape)
    
a = a.reshape((4, 1))
# or you might see this syntax: a = a[:, np.newaxis]
print(a.shape)
print(b.shape)
print(a+b)
print((a+b).shape)

"""## Simple *numpy* exercise

I am sure that you were already familiar with all the concepts presented above, but a short recap is always welcomed. 

Now let's do a very simple exercise with *numpy* arrays.

In a (4, 7) *numpy* array we store the statistics about coronavirus cases in the last week in our country.
The rows specify the number of tests with a positive test result, the number of tests with a negative test result (first testing for the subject), the number of inconclusive tests and the number of fatalities, respectively. 
The columns specify the day of the week for which the statistics were reported.
    
Compute the following (without using any explicity for loop):
- the total number of tests performed each day
- the percentage of daily positive tests and the percentage of daily inconclusive tests (as an array with 2 rows and 7 columns)
- the day in which the maximum number of deaths occured
- the sum of daily deaths and positive test results for each working day (the result with be an array with 5 elements)
- the number of positive tests results, the number of tests with a negative test result, the number of inconclusive tests and the number of fatalities for the week as a (1, 4) array

"""

days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
statistics = np.array([
                      [1200, 1234, 1580, 1468, 1300, 1367, 800], # positive test results
                      [24356, 24136, 22656, 22111, 22346, 18900, 14000], # negative test results
                      [134, 100, 491, 500, 301, 200, 300],  # inconclusive tests
                      [23, 14, 15, 16, 7, 5, 1]]) # number of fatalities

## YOUR CODE HERE
totalNumberOfTests = np.sum(statistics[:-1], axis=0)
percentageOfDailyPositiveAndInconclusiveTests = statistics[[0, 2]]/np.sum(statistics[:-1], axis=0) * 100
dayWithMaxDeaths = days[np.argmax(statistics[-1])]
positiveAndDeaths = np.sum(statistics[:, :5][[0, -1]], axis=0)
sumOverColumns = np.resize(np.sum(statistics, axis=1), (1, 4))

print(f"The total number of tests performed each day is: {totalNumberOfTests}")
print(f"The percentage of daily positive tests and the percentage of daily inconclusive tests: {percentageOfDailyPositiveAndInconclusiveTests}")
print(f"The day in which the maximum number of deaths occured is: {dayWithMaxDeaths}")
print(f"The sum of daily deaths and positive test results for each working day is: {positiveAndDeaths}")
print(f"The number of positive tests results, the number of tests with a negative test result, the number of inconclusive tests and the number of fatalities for the week: {sumOverColumns}")

"""Expected output:

The total number of tests performed each day is:
[25690 25470 24727 24079 23947 20467 15100]

The percentage of daily positive tests and the percentage of daily inconclusive tests:
[[4.67107824 4.84491559 6.38977636 6.0965987  5.42865495 6.67904432
  5.29801325]
 [0.52160374 0.39261877 1.98568367 2.07649819 1.25694241 0.97718278
  1.98675497]]

The day in which the maximum number of deaths occured is:
Monday

The sum of daily deaths and positive test results for each working day is: 
[[1223 1248 1595 1484 1307]]

The number of positive tests results, the number of tests with a negative test result, the number of inconclusive tests and the number of fatalities for the week: 
[[  8949 148505   2026     81]]

# Plotting

During this course we'll frequently create plots to show the distribution of some data, to show the performance of the developed models etc. We'll use the *matplotlib* library for this.

Using this library is straightforward, and the function that we'll use the most is plot(). You can check more about this library in the documentation: https://matplotlib.org/3.3.1/contents.html .

For example, to display a sine wave we could do the following:
"""

import numpy as np
import matplotlib.pyplot as plt

# compute the x range
x = np.arange(0, 5 * np.pi, 0.1)
y = np.sin(x)

plt.plot(x, y)

# set the title and the name of the x and y axes
plt.title('Sine function')
plt.ylabel('sine value')

# show the figure
plt.show()

"""We can plot different data in the same plot using subplot. Below is an example:"""

# compute the x range 
x = np.arange(0, 2 * np.pi, 0.1)
y_sin = np.sin(x)
y_cos = np.cos(x)

# subplot with 1 row and 2 columns
# the first subplot is the active one
plt.subplot(1, 2, 1)

# Make the first plot
plt.plot(x, y_sin)
plt.grid(True)
plt.title('Sine')

# activate the second plot
plt.subplot(1, 2, 2)
plt.plot(x, y_cos)
plt.title('Cosine')

# adjust the spacing between the plots
plt.subplots_adjust(wspace=0.5)
plt.show()

"""You might be familiar from the Artificial Intelligence class with some of the activation functions used in neural networks: ReLU, tahh, sigmoid and their friends. In the image below you have the common activation functions depicted as dance moves.




Pick your favourite three "dance moves" and plot them with matplotlib using subplots. 
"""

dance_moves_img = cv2.imread('dance_moves.png')
dpi = plt.rcParams['figure.dpi']

height, width, depth = dance_moves_img.shape
figsize = width / float(dpi), height / float(dpi)
plt.figure(figsize=figsize)
plt.imshow(dance_moves_img)

## YOUR CODE HERE
x = np.arange(-10, 10, 0.01)
y_sigmoid = 1/(1+np.exp(-x))
y_leaky_relu = np.where(x > 0, x, x * 0.01)
y_swish = x/(1+np.exp(-x))

plt.subplot(1, 3, 1)
plt.plot(x, y_sigmoid)

plt.title('Sigmoid Function')
plt.ylabel('Sigmoid Value')

plt.subplot(1, 3, 2)
plt.plot(x, y_leaky_relu)

plt.title('LeakyReLU Function')
plt.ylabel('LeakyReLU Value')

plt.subplot(1, 3, 3)
plt.plot(x, y_swish)

plt.title('Swish Function')
plt.ylabel('Swish Value')

plt.show()

"""# Image manipulation

Computer vision is about images (or image sequences), so you'll definetely need some image manipulation skills.
For now, we'll just need some functions to read and write images. 

We'll use the *opencv* library to work images; opencv is an open-source, cross-platform computer vision library and it support a variety of programming languages (C++, Python, Java).

The python version of opencv is very simple and it allows you to express your brilliant ideas in fewer line of codes, while maintaining a hight readability of the code.

### Reading, writing and displaying an image

To read an image you'll use the <i>imread</i> function from the opencv library. To display an image you can use the <i>imshow</i> function from the matplolib library . 
Pretty simple, isn't it?
"""

img = cv2.imread('cute_cat.jpg') # BGR , RGB
# BGR -> RGB
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # opencv uses BGR channel ordering, while matplotlib uses RGB channel ordering

plt.imshow(img)

"""An image is esentially just a numpy array. The type of the elements stored in this array is np.uint8, so each element ranges from 0 (corresponding to the black color in grayscale images) and 255 (corresponding to the white color in grayscale images).

To get the size of the image, we can use the <i>size</i> attribute.
"""

img_height, img_width, img_channels = img.shape[0], img.shape[1], img.shape[2]
print('The image resolution is ', img_width, 'x', img_height)
print('The number of channels is ', img_channels)

"""You can use the function imresize to change the resolution of an image."""

# resize image to (120, 400) - breaks the aspect ratio
img_resize_fixed =  cv2.resize(img, (120, 400))
print('The shape of the resize image is:', img_resize_fixed.shape)
plt.imshow(img_resize_fixed)

# resize the image to w/4 x h/4 (keeps the aspect ratio)
img_resize_prop = cv2.resize(img, (0, 0), fx=0.25, fy=0.25)
print('The shape of the resize image is:', img_resize_prop.shape)
plt.imshow(img_resize_prop)

"""A color image consists of 3 image channels (the red, green and blue channels).

A grayscale image has a single channel. One way of converting a color image to grayscale is using the equation:

Gray = 0.2126 R + 0.7152 G + 0.0722 B

,where R, G and B are the red, green and blue channels of the input image.
"""

img_gray = 0.2126*img_resize_prop[:,:,0] + 0.7152*img_resize_prop[:,:,1] + 0.0722*img_resize_prop[:,:,2]
img_gray = img_gray.astype(np.uint8)
plt.imshow(img_gray, cmap='gray', vmin=0, vmax=255) # use cmap='gray' (colormap) to display a grayscale image

"""A histogram is graphical representation of the grayscale values (or color tones in the input image). From a histogram we can determine statistical properties of the image, such as the average brightess and the contrast of the image.

"""

hist, bins = np.histogram(img_gray, bins=255)# [0-255], 256

print('The histogram is:\n', hist)

plt.bar(np.arange(255), hist, color='cornflowerblue')
plt.title('histogram of the grayscale image')

"""Plot the histograms of the red, blue and green channel of an image on the same plot. The histogram of the red channel should be displayed in red bars, the histogram of the blue channel should be displayed in blue bars and the histogram of the green channel should be displayed with green bars."""

## YOUR CODE HERE
image = cv2.imread('cute_cat.jpg') 
# BGR -> RGB
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

plt.title('Histogram')

plt.rcParams["figure.figsize"] = (30,10)
hist, bins = np.histogram(image[:, :, 0], bins=255)
plt.bar(np.arange(255), hist, color='red')

hist, bins = np.histogram(image[:, :, 1], bins=255)
plt.bar(np.arange(255), hist, color='green')

hist, bins = np.histogram(image[:, :, 2], bins=255)
plt.bar(np.arange(255), hist, color='blue')

plt.show()

"""Add to each element in the grayscale image with a positive number and store the result in img_l1. 
What do you think is the effect of this operation? Display the image img_l1. Make sure that the result is in the range [0, 255].
"""

# YOUR CODE THERE
image = cv2.imread('cute_cat.jpg') 
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
image_gray = 0.2126*image[:,:,0] + 0.7152*image[:,:,1] + 0.0722*image[:,:,2]
image_l1 = np.clip(image_gray + 50, 0, 255) # brightens up the image
image_l1 = image_l1.astype(np.uint8)

plt.subplot(1, 2, 1)
plt.imshow(image_gray, cmap='gray', vmin=0, vmax=255) 

plt.subplot(1, 2, 2)
plt.imshow(image_l1, cmap='gray', vmin=0, vmax=255)

"""Compute and display the histogram of img_l1.  What do you notice? How is this histogram different than the previous one?"""

## YOUR CODE HERE
histogram, bins = np.histogram(image_l1, bins=205)# [50-255]
histogram = np.concatenate((np.zeros(50, dtype="uint8"), histogram))

plt.bar(np.arange(255), histogram, color='blue')
plt.title('Histogram')
# We can notice that the values are shifted to the right with most of them reaching 255

"""Now add to the grayscale image a negative number and store the result in img_l2. 
If the resulting value is less than 0, clamp it to this 0.

What do you think is the effect of this operation?
"""

## YOUR CODE HERE
image = cv2.imread('cute_cat.jpg') 
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
image_gray = 0.2126*image[:,:,0] + 0.7152*image[:,:,1] + 0.0722*image[:,:,2]
image_l2 = np.clip(image_gray - 50, 0, 255) # darkens up the image
image_l2 = image_l2.astype(np.uint8)

plt.subplot(1, 2, 1)
plt.imshow(image_gray, cmap='gray', vmin=0, vmax=255) 

plt.subplot(1, 2, 2)
plt.imshow(image_l2, cmap='gray', vmin=0, vmax=255)

"""Compute and display the histogram of img_l2. What do you notice? How is this histogram different than the previous ones?"""

## YOUR CODE HERE
histogram, bins = np.histogram(image_l2, bins=205)
histogram = np.concatenate((histogram, np.zeros(50, dtype="uint8")))

plt.bar(np.arange(255), histogram, color='blue')
plt.title('Histogram')
# The values shifted to the left, most of them reaching 0

"""Add a positive number (for example 40) to the red channel of the color image and store the result in imgg. If the result of the addition exceeds 255, clamp it to 255.
What do you think is the effect of this operation?
Display the resulting image imgr.
"""

image = cv2.imread('cute_cat.jpg') 
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
plt.subplot(1, 2, 1)
plt.imshow(image) 
print(image[0][0])

image_red = image + np.array([40, 0, 0]) # As expected, it makes the image reddish, simillar to sepia filter
image_red = np.clip(image_red, 0, 255) 
print(image_red[0][0])
cv2.imwrite('imgr.png', image_red)
plt.subplot(1, 2, 2)
plt.imshow(image_red)

"""Display a region of interest from the input image defined by the rectangle (x=350, y=400, sz=(500x400)). 

Hint: an image is just a numpy array, so you can easily achieve this with array slicing.
"""

## YOUR CODE HERE
image = cv2.imread('cute_cat.jpg') 
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
x=350
y=400
size = (500, 400)
image = image[x:x+size[0], y:y+size[1], :]
plt.imshow(image)

"""# Hello convolutional neural networks !

In the last part of this introductory laboratory, you'll "meet" a convolutional network for object classification. For now, consider it just as a black box that takes an image as input and outputs the 3-top predictions; however this network requires that the input data has the following properties:
- the size of the input image must be 224x224
- the channels of the image should be stored in BGR format
- the type of the data (of the numpy array) is float32
- the values  [103.939, 116.779, 123.68] (BGR mean) should be subtracted from each pixel of the array
- prior to feeding the image to model.predict() should be added such that the shape of the image is (1, 224, 224, 3)

Your task is to pre-process the input images such that they are in the format requested by the network. 
"""

import tensorflow as tf
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.applications.resnet import decode_predictions

model = ResNet50(weights='imagenet')

!wget "https://docs.google.com/uc?export=download&id=1X9au_JCNv4fg2Wgsr4DFT-N0OZht6Zmp" -O elephant.jpg

from keras.preprocessing import image
from tensorflow.keras.applications.resnet import preprocess_input

img_path = './elephant.jpg'

im = cv2.imread(img_path)

## TODO YOUR CODE HERE
def pre_processor(image):
  image = image.astype(np.float32)
  image = cv2.resize(image, (224, 224))
  image = image - np.array([103.939, 116.779, 123.68])
  return image[np.newaxis, :, :, :]

im = pre_processor(im)

preds = model.predict(im)

# decode the results into a list of tuples (class, description, probability)
# (one such list for each sample in the batch)
predictions = decode_predictions(preds, top=3)[0]
print('The top 3 predictions are: ')
for pred in predictions:
    print('\t %s with probability %0.2f%%'% (pred[1], float(pred[2])*100))

"""Apply different effects (crop it, lower the contrast, change the brightness) on the training image and see if you can "fool" the network.

Also, upload other images from your computer and see what the network predicts
"""

print("Test 1")
image_path = './elephant.jpg'
image = cv2.imread(image_path)

image = image[0:250, 410:610, :]
image = np.clip(image, 0, 255)
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
image = pre_processor(image)

preds = model.predict(image)

# decode the results into a list of tuples (class, description, probability)
# (one such list for each sample in the batch)
predictions = decode_predictions(preds, top=3)[0]
print('The top 3 predictions are: ')
for pred in predictions:
    print('\t %s with probability %0.2f%%'% (pred[1], float(pred[2])*100))
	
	
print("Test 2")
image_path = './fd_pb.jpg'
image = cv2.imread(image_path)
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
image = pre_processor(image)
preds = model.predict(image)

# decode the results into a list of tuples (class, description, probability)
# (one such list for each sample in the batch)
predictions = decode_predictions(preds, top=3)[0]
print('The top 3 predictions are: ')
for pred in predictions:
    print('\t %s with probability %0.2f%%'% (pred[1], float(pred[2])*100))

"""Congratulations for reaching this point! This is the end of first laboratory.
Next time we'll build (from scratch) a simple linear classifier to recognize different objects from images.
"""



"""It would be great if you could tell me what you liked (or not) about this tutorial, so I can make it better for the next iteration! [feedback form](https://docs.google.com/forms/d/1hh3qUKsbVtKnRb2SS_bY7o52jf5O8n4-N6icuBv3F1k/)
Thank you!
"""